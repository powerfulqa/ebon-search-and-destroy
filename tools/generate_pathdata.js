const fs = require("fs");
const path = require("path");

const inputPath = path.join(__dirname, "vanilla_rares.json");
const outputDir = path.join(__dirname, "output");
const pathDataPath = path.join(outputDir, "PathData_vanilla.lua");
const zoneDataPath = path.join(outputDir, "ZoneData_vanilla.lua");

function readJson(filePath) {
  const raw = fs.readFileSync(filePath, "utf8");
  return JSON.parse(raw);
}

function clampUint16(value) {
  if (value < 0) return 0;
  if (value > 0xffff) return 0xffff;
  return value;
}

function packCoord(coord) {
  const scaled = Math.floor(coord * 65535);
  const v = clampUint16(scaled);
  return [v & 0xff, (v >> 8) & 0xff];
}

function packPoint(x, y) {
  const xBytes = packCoord(x);
  const yBytes = packCoord(y);
  return [xBytes[0], xBytes[1], yBytes[0], yBytes[1]];
}

function validateZones(data) {
  if (!data || !Array.isArray(data.zones)) {
    throw new Error("Input JSON must contain a zones array.");
  }
  data.zones.forEach((zone, index) => {
    if (typeof zone.mapID !== "number") {
      throw new Error(`zones[${index}].mapID must be a number.`);
    }
    if (typeof zone.width !== "number" || typeof zone.height !== "number") {
      throw new Error(`zones[${index}].width/height must be numbers.`);
    }
    if (typeof zone.zoneName !== "string") {
      throw new Error(`zones[${index}].zoneName must be a string.`);
    }
    if (!Array.isArray(zone.npcs)) {
      throw new Error(`zones[${index}].npcs must be an array.`);
    }
    zone.npcs.forEach((npc, npcIndex) => {
      if (typeof npc.id !== "number") {
        throw new Error(`zones[${index}].npcs[${npcIndex}].id must be a number.`);
      }
      if (typeof npc.name !== "string") {
        throw new Error(`zones[${index}].npcs[${npcIndex}].name must be a string.`);
      }
      if (typeof npc.x !== "number" || typeof npc.y !== "number") {
        throw new Error(`zones[${index}].npcs[${npcIndex}].x/y must be numbers.`);
      }
    });
  });
}

function toLuaStringChar(bytes) {
  return `string.char(${bytes.join(", ")})`;
}

function buildPathData(zones) {
  const lines = [];
  lines.push("-- GENERATED BY tools/generate_pathdata.js");
  lines.push("select( 2, ... ).PathData = {");

  zones.forEach((zone) => {
    if (!zone.npcs.length) {
      return;
    }

    lines.push(`\t[ ${zone.mapID} ] = { -- ${zone.zoneName}`);
    zone.npcs.forEach((npc) => {
      const point = packPoint(npc.x, npc.y);
      const bytes = [].concat(point, point, point);
      lines.push(`\t\t-- ${npc.name}`);
      lines.push(`\t\t[ ${npc.id} ] = ${toLuaStringChar(bytes)};`);
    });
    lines.push("\t};");
  });

  lines.push("};");
  lines.push("");
  return lines.join("\n");
}

function buildZoneData(zones) {
  const lines = [];
  lines.push("-- GENERATED BY tools/generate_pathdata.js");
  lines.push("-- Add(MapID, Width, Height) entries");

  zones.forEach((zone) => {
    lines.push(`Add( ${zone.mapID}, ${zone.width}, ${zone.height} ); -- ${zone.zoneName}`);
  });

  lines.push("");
  return lines.join("\n");
}

function main() {
  if (!fs.existsSync(inputPath)) {
    throw new Error(`Missing input file: ${inputPath}`);
  }

  const data = readJson(inputPath);
  validateZones(data);

  fs.mkdirSync(outputDir, { recursive: true });

  const pathData = buildPathData(data.zones);
  const zoneData = buildZoneData(data.zones);

  fs.writeFileSync(pathDataPath, pathData, "utf8");
  fs.writeFileSync(zoneDataPath, zoneData, "utf8");

  console.log("Wrote:");
  console.log(`- ${pathDataPath}`);
  console.log(`- ${zoneDataPath}`);
}

try {
  main();
} catch (error) {
  console.error(error.message || error);
  process.exit(1);
}
